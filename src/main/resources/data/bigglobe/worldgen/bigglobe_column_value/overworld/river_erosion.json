{
	"type": "script",
	"params": {
		"type": "double",
		"is_3d": false
	},
	"script": [
		"double cosCurve(double x:",
			"x ^= 2",
			"(1.0L - 16.0L * x) * (1.0L - (16.0L - 4.0L * pi) * x)",
		")",
		"",
		"double approxSin(double x:",
			"x *= 1.0L / tau",
			"x -= floor(x)",
			"x <= 0.5L ? cosCurve(x - 0.25L) : -cosCurve(x - 0.75L)",
		")",
		"",
		"double approxCos(double x:",
			"approxSin(x + pi * 0.5L)",
		")",
		"",
		"double*(",
			"result = 0.0L",
			"theta = (worldSeed # 16x9BFEE7B64C530DA1UL).nextDouble(tau)",
			"unitX = cos(theta)",
			"unitZ = sin(theta)",
			"goldenTheta = 2.39996322972865332L",
			"goldenCos = cos(goldenTheta)",
			"goldenSin = sin(goldenTheta)",
			"baseAmplitude = 16.0L",
			"decay = 2.0L ^ (-1.0L / 64.0L)",
			"dx = dx_raw_rivers * 256.0L",
			"dz = dz_raw_rivers * 256.0L",
			"div = (sqrt(dx ^ 2 + dz ^ 2) + 4.0) * sign(raw_rivers)",
		")",
		"dx /= div",
		"dz /= div",
		"",
		"for (int loop in range[0, 256 - hints.lod << 6):",
			"long seed = (worldSeed # 16x514ACE8AAED67DACUL).newSeed(loop)",
			"double*(",
				"unitXTmp = unitX * goldenCos + unitZ * -goldenSin",
				"unitZTmp = unitX * goldenSin + unitZ *  goldenCos",
			")",
			"unitX = unitXTmp",
			"unitZ = unitZTmp",
			"double*(",
				"phase = (seed := seed.newSeed()).nextDouble(tau)",
				"projection = (unitX * x + unitZ * z) + phase",
				";adjustedAmplitude = (unitX * -dz + unitZ * dx) ^ 2",
				"adjustedAmplitude = ((unitX * -dz + unitZ * dx) / (sqrt(dx ^ 2 + dz ^ 2) + 4.0)) ^ 2",
				"tmpSin = approxSin(projection / baseAmplitude) * baseAmplitude * adjustedAmplitude",
				"tmpCos = approxCos(projection / baseAmplitude) * adjustedAmplitude",
			")",
			"dx += tmpCos * unitX",
			"dz += tmpCos * unitZ",
			"result += tmpSin",
			"baseAmplitude *= decay",
		")",
		"return(result)"
	]
}